# -*- coding: utf-8 -*-
"""batchVideoPreprocess.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11S0ABUA3zzNtZk_UZB7oEFI3UbZn1XSJ
"""

from google.colab import drive
drive.mount('/content/gdrive')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import cv2
import os
import glob

path = '/content/gdrive/MyDrive/Trimester02/Dataset/CSVs/*.csv'

csv_files = glob.glob(path)
print(csv_files)

for file in csv_files:
    df = pd.read_csv(file)
    print(f"Contents of {file}:")
    display(df)  # Use display() for pretty printing in Colab
    print("\n")

print(len(csv_files))

def extract_video_chunk(video_path, start_duration, end_duration, output_folder, video_name):
    # Check if output folder exists, if not, create it
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    # Load the video
    cap = cv2.VideoCapture(video_path)

    # Check if the video is successfully loaded
    if not cap.isOpened():
        print("Error: Unable to open the video file.")
        return

    # Get video properties
    fps = cap.get(cv2.CAP_PROP_FPS)
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    total_duration = total_frames / fps * 1000  # Total duration in milliseconds

    # Convert start and end duration to frames
    start_frame = int(start_duration * fps / 1000)
    end_frame = int(end_duration * fps / 1000)

    # Check if the provided start and end durations are within the video duration
    if start_duration < 0 or start_duration > total_duration or end_duration < 0 or end_duration > total_duration:
        print("Error: Invalid start or end duration.")
        return

    # Set the start frame
    cap.set(cv2.CAP_PROP_POS_FRAMES, start_frame)

    # Read and save the video chunk
    frames = []
    for frame_num in range(start_frame, end_frame):
        ret, frame = cap.read()
        if ret:
            frames.append(frame)
        else:
            break

    # Save the chunk as a video
    if frames:
        output_video_path = os.path.join(output_folder, f"{video_name}.mp4")
        out = cv2.VideoWriter(output_video_path, cv2.VideoWriter_fourcc(*'mp4v'), fps, (frames[0].shape[1], frames[0].shape[0]))
        for frame in frames:
            out.write(frame)
        out.release()
        print(video_name)
    # Release the video capture
    cap.release()

def extract_video_chunk_avi(video_path, start_duration, end_duration, output_folder, video_name, output_fps=15):
    # Check if output folder exists, if not, create it
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    # Load the video
    cap = cv2.VideoCapture(video_path)

    # Check if the video is successfully loaded
    if not cap.isOpened():
        print("Error: Unable to open the video file.")
        return

    # Get video properties
    fps = cap.get(cv2.CAP_PROP_FPS)
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    total_duration = total_frames / fps * 1000  # Total duration in milliseconds

    # Convert start and end duration to frames
    start_frame = int(start_duration * fps / 1000)
    end_frame = int(end_duration * fps / 1000)

    # Check if the provided start and end durations are within the video duration
    if start_duration < 0 or start_duration > total_duration or end_duration < 0 or end_duration > total_duration:
        print("Error: Invalid start or end duration.")
        return

    # Set the start frame
    cap.set(cv2.CAP_PROP_POS_FRAMES, start_frame)

    # Read and save the video chunk
    frames = []
    while cap.isOpened() and cap.get(cv2.CAP_PROP_POS_FRAMES) <= end_frame:
        ret, frame = cap.read()
        if ret:
            frames.append(frame)
        else:
            break

    # Save the chunk as a video
    if frames:
        output_video_path = os.path.join(output_folder, f"{video_name}.avi")
        out = cv2.VideoWriter(output_video_path, cv2.VideoWriter_fourcc(*'XVID'), output_fps, (frames[0].shape[1], frames[0].shape[0]))
        for frame in frames:
            out.write(frame)
            print("Ok")
        out.release()

    # Release the video capture
    cap.release()

Update the paths accordingly

video_path = "/content/drive/MyDrive/Trimester02/Dataset/Raw_Videos"
csv_path = "/content/drive/MyDrive/Trimester02/Dataset/CSVs"
start_duration = 0
end_duration = 0
output_folder = "/content/drive/MyDrive/Trimester02/Dataset/Chunk01"
clear_path = "/content/drive/MyDrive/Trimester02/Dataset/Chunk01/Clear"
knock_down_path = "/content/drive/MyDrive/Trimester02/Dataset/Chunk01/KnockDown"
Unidentified = "/content/drive/MyDrive/Trimester02/Dataset/Chunk01/Unidentified"
parallel_path = ""
upright_path = ""
indoor_path = ""
outdoor_path = ""

for index, row in df.iterrows():
    start_duration = row['Position']
    duration = row['Duration']
    end_duration = start_duration + duration
    extract_video_chunk(video_path, start_duration+850, end_duration, output_folder, duration)

def process_csv_and_videos(csv_folder_path, videos_folder_path, folder_a_path, folder_b_path):
    csv_files = glob.glob(os.path.join(csv_folder_path, '*.csv'))

    for csv_file in csv_files:
        df = pd.read_csv(csv_file)
        video_name = os.path.basename(csv_file).replace('.csv', '.mp4')  # Assuming video format is .mp4
        video_path = os.path.join(videos_folder_path, video_name)

        for index, row in df.iterrows():
            if index + 1 < len(df):
              next_row = df.iloc[index + 1]
              # Now use 'next_row' instead of 'row' for your processing
              start_duration_next = int(next_row['Position'])

            start_duration = start_duration_next #int(row['Position'])
            jump_duration = 1750
            duration = int(row['Duration'])


            jump_outcome = "Unidentified"
            if row['Jump Outcome'] == 'Clear':
              output_folder = folder_a_path
              jump_outcome = "Clear"
            elif row['Jump Outcome'] == 'Knock Down':
              output_folder = folder_b_path
              jump_outcome = "Knock Down"
            else:
              output_folder = Unidentified
              jump_outcome = "Unidentified"


            # Adjust start time as needed
            if start_duration < 500:
              start_duration = 0
            else:
              start_duration -= 500
            end_duration = start_duration + jump_duration
            print("start_duration:", start_duration)
            print("end_duration:", end_duration)
            extract_video_chunk(video_path, start_duration, end_duration, output_folder, f"{video_name}_{start_duration}-{end_duration}_{jump_outcome}_{index+1}")

process_csv_and_videos(csv_path, video_path, clear_path, knock_down_path)

"""Video Spliting process Finished here.


Following code is to check if the number of videos and csv files are same count
"""

# List files in both folders
video_files = os.listdir(video_path)
csv_files = os.listdir(csv_path)

# Extract file names without extensions
video_file_names = set([os.path.splitext(file)[0] for file in video_files])
csv_file_names = set([os.path.splitext(file)[0] for file in csv_files])

# Find intersection of both sets to get matching file names
matching_file_names = video_file_names.intersection(csv_file_names)

# Count the matching file names
number_of_matching_files = len(matching_file_names)

print(f"Number of files with the same name: {number_of_matching_files}")

"""The following code is used to create suitable dataset for MMAction2"""

import os
import shutil
from sklearn.model_selection import train_test_split
import uuid

def generate_random_filename(label):
    random_string = str(uuid.uuid4())[:8]  # Generate a random string
    new_filename = f"{random_string}{label}.mp4"  # Append the label at the end
    return new_filename

# Function to get video files and labels
def get_videos_and_labels(clear_path, unclear_path):
    videos_labels = [(os.path.join(clear_path, f), '1') for f in os.listdir(clear_path)] + \
                    [(os.path.join(unclear_path, f), '0') for f in os.listdir(unclear_path)]
    return videos_labels

# Function to split data
def split_data(videos_labels, test_size=0.2):
    # Split data into training and validation sets
    train, val = train_test_split(videos_labels, test_size=test_size, random_state=42)
    return train, val

# Function to copy videos to their respective directories, rename, and write annotations
def organize_dataset(videos_labels, dataset_path, annotations_file):
    os.makedirs(dataset_path, exist_ok=True)
    counter = 1  # Counter for unique file names
    with open(annotations_file, 'w') as f:
        for video_path, label in videos_labels:
            extension = os.path.splitext(video_path)[1]
            new_name = generate_random_filename(label)  # Generates 'video_[label]_[number].[extension]'
            new_path = os.path.join(dataset_path, new_name)
            shutil.copy(video_path, new_path)  # Copy and rename video
            f.write(f'{new_name} {label}\n')  # Write new file name and label to annotations
            counter += 1

# Main
if __name__ == "__main__":
    clear_videos_path = '/content/gdrive/MyDrive/Trimester02/Dataset/MMAction2/Clear'
    unclear_videos_path = '/content/gdrive/MyDrive/Trimester02/Dataset/MMAction2/KnockDown'
    base_path = '/content/gdrive/MyDrive/Trimester02/Dataset/MMAction2/'

    # Get videos and labels
    videos_labels = get_videos_and_labels(clear_videos_path, unclear_videos_path)

    # Split into training and validation sets
    train_videos, val_videos = split_data(videos_labels)

    # Organize training set
    train_path = os.path.join(base_path, 'train')
    train_annotations = os.path.join(base_path, 'train.txt')
    organize_dataset(train_videos, train_path, train_annotations)

    # Organize validation set
    val_path = os.path.join(base_path, 'val')
    val_annotations = os.path.join(base_path, 'val.txt')
    organize_dataset(val_videos, val_path, val_annotations)